# CS

## 1. MySQL :vs: NoSQL

### 1) MySQL (관계형 데이터베이스)

- SQL => Structured Query Language, 데이터베이스와 상호작용 하는데 사용하는 쿼리 언어 

- 관계형 데이터베이스 특징

  - 데이터는 정해진(엄격한) 데이터 스키마를 따라 데이터베이스 테이블에 저장된다.
  - 데이터는 관계를 통해서 연결된 여러개의 테이블에 분산된다.

  

> 1. **엄격한 스키마**
>
> - 데이터는 테이블에 레코드로 저장, 각 테이블에는 명확하게 정의된 구조가 있음. 
>   - 구조란 어떤 데이터가 테이블에 들어가고 어떤 데이터가 그렇지 않을지를 정의하는 필드 집합 
>   - 구조는 필드의 이름과 데이터 유형으로 정의
> - 관계형 데이터베이스에서 스키마를 준수하지 않는 레코드는 추가할 수 없음. 
>
> 
>
> 2. **관계**
>
> - 데이터들을 여러개의 테이블에 나누어서, 데이터들의 중복을 피할 수 있음. 
> - 다른 테이블에서 부정확한 데이터를 다룰 위험이 없다는 장점



### 2) NoSQL (비관계형 데이터베이스)

- SQL과 반대되는 접근 방식
  - 스키마 없음
  - 관계 없음
- 일반적으로 관련 데이터를 동일한 컬렉션에 넣는다. 
  - Orders 컬렉션에 Users나 Products 정보 또한 포함해서 저장이 가능
  - 여러 테이블/ 콜렉션 조인이 필요 없음. 
- 데이터가 중복되기 때문에 불안정한 단점 
  - 컬렉션 B에서 데이터를 수정하지 않았는데, A에서만 데이터를 업데이트 할 위험
  - 특정 데이터를 같이 사용하는 모든 컬렉션에서, 똑같은 데이터를 업데이트 수정되도록 해야한다.
- 조인을 사용할 필요가 없다는 큰 장점 
  - 자주 변경되지 않는 데이터 일때 더 큰 장점



### 3) 수직적(Vertical) & 수평적(Horizontal) 확장(Scaling)

> 1. **수직적 확장**
>    - 단순히 데이터베이스 서버의 성능을 향상시키는 것 
>    - ex ) CPU를 업그레이드 하는 방식
> 2. **수평적 확장**
>    - 더 많은 서버가 추가되고, 데이터베이스가 전체적으로 분산됨 
>    - 하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동
>
> ![image-20201028214607380](CS.assets/image-20201028214607380.png)
>
> *** SQL 데이터 베이스는 일반적으로 수직적 확장만을 지원 
>
> *** 수평적 확장은 NoSQL 데이터베이스에서만 가능 





### 4) 장/단점 정리

> #### 1. SQL 장점
>
> - 명확하게 정의 된 스키마, 데이터 무결성 보장 
> - 관계는 각 데이터를 중복없이 한번만 저장됨 
>
> #### 2. SQL 단점
>
> - 상대적 덜 유연, 데이터 스키마는 사전에 계획되고 알려져야 한다. (후에 수정은 불가능 할 수도 있다.)
> - 관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있음
> - 대체로 수직정 확장만 가능, 즉, 어떤 시점에서(처리량과 관련하여) 성장 한계에 직면하게 됨



>#### 1. NoSQL 장점
>
>- 스키마가 없기 때문에 훨씬 유연, 즉, 언제든지 저장된 데이터 조정하고 새로운 필드 추가 가능 
>- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨, 데이터를 읽어오는 속도가 빨라짐
>- 수직 및 수평 확장이 가능, 데이터 베이스가 애플리케이션에서 발생시키는 모든 읽기/쓰기 요청을 처리할 수 있음
>
>#### 2. NoSQL 단점
>
>- 유연성 때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수도 있음
>- 데이터 중복은 여러 컬렉션과 문서가 여러 개의 레코드가 변경된 경우 업데이트 해야 함
>- 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정해야 하는경우 모든 컬렉션에서 수행해야 함 



> #### SQL을 사용하면 좋은 경우 ? 
>
> - 관계를 맺고 있는 데이터가 자주 변경(수정)되는 애플리케이션일 경우
>
>   ( NoSQL 에서는 여러 컬렉션을 모두 수정해줘야 하기 때문에)
>
> - 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우



> #### NoSQL을 사용하면 좋은 경우?
>
> - 정확한 데이터 구조를 알 수 없거나 변경/ 확장 될 수 있는 경우
> - 읽기 처리를 자주 하지만, 데이터를 자주 변경하지 않는 경우 
> - 데이터 베이스를 수평적으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)



## 2. OS
### 1. Thread란 ?

> - 쓰레드란 **프로그램(프로세스)의 실행 단위**, 하나의 프로세스는 여러개의 쓰레드로 구성이 가능
>
> - 하나의 프로세스를 구성하는 쓰레드들은 프로세스에 할당된 메모리, 자원 등을 공유
>
> - 프로세스와 같이 실행, 준비, 대기 등의 실행상태 가짐 
>
> - 각 쓰레드별로 자신만의 스택과 레지스터 가짐
>
>   ![image-20201108123059058](CS.assets/image-20201108123059058.png)
>
> - 한 순간에는 하나의 쓰레드만 실행 가능



#### 1) 프로세스와 쓰레드의 차이

> **프로세스** : 운영체제로부터 자원을 할당받는 작업의 단위
>
> - 프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 할당을 받을 수 있는 것



> **쓰레드** : 프로세스가 할당받은 자원을 이용하는 실행의 단위
>
> - 한 프로세스 내에서 동작되는 여러 실행 흐름, 프로세스 내의 주소 공간이나 자원 공유
> - 각각의 쓰레드는 독립적인 작업 수행, 각각의 stack과 PC resister를 가지고 있다. 



> **스택을 쓰레드마다 독립적으로 할당하는 이유 ?**
>
> - 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소 값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간
> - 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것, 이는 독립적인 실행 흐름이 가능하다
> - 독립적인 실행 흐름을 위한 최소 조건으로 독립된 스택 할당



> **PB Resister를 쓰레드마다 독립적으로 할당하는 이유 ?**
>
> - PC 값은 쓰레드가 명령어의 어디까지 수행하였는지를 나타냄
> - 쓰레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당함. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있음.
> - 따라서 PC resister를 독립적으로 할당함. 



#### 2) 쓰레드의 장점

- 쓰레드는 프로세스보다 생성 및 종료 시간, 쓰레드 간 전환 시간이 짧다.
- 쓰레드는 프로세스의 메모리, 자원 등을 공유하므로 커널의 도움 없이 상호간에 통신이 가능하다. 



#### 3) 쓰레드 동기화 방법의 종류

- Mutex / semaphore / Monitor
  - 세가지 모두 운영체제의 동기화 기법

> Mutex (Mutual Exclusion)
>
> - 쓰레드의 동시 접근을 허용하지 않는다는 의미
> - 뮤텍스의 쓰레드 동기화 방법은 임계영역에 들어가기 위해 이 뮤텍스를 가지고 있어야 들어갈 수 있음



> Semaphore
>
> - 세마포어는 동시 접근 동기화가 아닌 접근 순서 동기화에 더 관련 있음



> Monitor
>
> - Mutex와 Queue을 가지고 있는 Synchronization 메카니즘



- Mutex, Monitor는 상호 배제, 임계 구역에 하나의 쓰레드만 들어갈 수 있다.
- Semaphore는 하나의 쓰레드만 들어가거나 여러 개의 쓰레드가 들어갈 수 있다



> **Mutex** Vs **Monitor**
>
> - 뮤텍스
>   - 뮤텍스는 다른 프로세스(애플리케이션)간에 동기화를 위해 사용
>   - 운영체제 커널에 의해서 제공
>   - 무겁고 느림
> - 모니터
>   - 모니터는 하나의 프로세스(애플리케이션)내에 다른 쓰레드 간에 동기화 할 때 사용 
>   - 프레임워크나 라이브러리 그 자체에서 제공
>   - 가볍고 빠르다



> **Semaphore** Vs **Monitor**
>
> - 세마포어
>   - 카운터라는 변수 값으로 프로그래머가 상호 배제나 정렬의 목적으로 사용시, 매번 값을 따로 지정해줘야함
> - 모니터
>   - 이러한 일들이 캡슐화, 개발자는 카운터값을 1 또는 0으로 주어야 하는 고민 필요없이 synchronized(), wait() 등의 키워드를 이용해 좀 더 편하게 동기화



> Mutex Vs Semaphore
>
> - 세마포어
>   - 세마포어는 소유할 수 없음
>   - 하나 이상 동기화 가능
> - 뮤텍스
>   - 소유 할 수 있음, 소유자가 이에 책임
>   - 1개만 동기화 



### 3. 데드락

> **데드락**이란?
>
>  프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 의미합니다. 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생합니다. 해결 방법으로는 예방, 회피, 회복, 무시 등의 4가지 방법이 있습니다. 



> **예방**은 교착 상태가 일어나는 조건 (상호 배제, 점유와 대기, 비선점, 환형대기)이 발생하지 않도록 하나만 해결하는 것, 
>
> **회피**는 교착 상태의 발생 조건을 없애기 보다는 발생하지 않도록 알고리즘을 적용하는 방법, 
>
> **회복**은 교착상태가 발생하는 것을 막지는 않고, 발생하면 발생 이후에 문제를 해결하는 방법, 
>
> **무시**는 교착 상태를 해결할 때 발생하는 성능 저하가 더 크면 그냥 무시해버리는 것 